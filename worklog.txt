I am starting to work through Ray Tracing in One Weekend.


RTIOW: 1. Overview
Ray tracing: a path tracer.
Final Outcome: a ray tracer that produces some great images.
Why C++: fast, portable, and most production movie and video game renderers are written in C++.


RTIOW: 2.1 The PPM Image Format
Way to see an image: write it to a file.
For plain text ppm file, some Notes in C++:
First, pixels: write from left to right
Second, rows: write from top to bottom
Third, each of components range: high dynamic


RTIOW: 2.2 Creating an Image File
We need to redirect it to an image file. (because the file is written to the program output) -- Use > (which is a redirection operator)
For Mac/Linux: build/inOneWeekend > image.ppm
For Windows: build\Release\inOneWeekend.exe > image.ppm
On Mac, using ToyViewer to open the output file (or Google "ppm viewer")


RTIOW: 2.3 Adding a Progress Indicator
Advantages: track the progress of a long render; identify a run that's stalled out due to an infinite loop or other problem.
image -- std::cout
error -- std::cerr


RTIOW: 3. The vec3 Class
Almost all graphics programs -- some classes for storing geometric vectors and colors.
Vectors are 4D: 3D+a homogeneous coordinate for geometry & RGB+an alpha transparency channels for colors.
We use the same class vec3 for colors, locations, directions, offsets, etc.
Two aliases for vec3: point2 and color.


RTIOW: 3.1 Variables and Methods
vec3 class: public
default conductor, conductor, assignment operators
We use double (but some ray tracers use float, both ok)
//Type aliases for vec3
using point3 = vec3; // 3D point
using color = vec3; // RGB color


RTIOW: 3.2 vec3 Utility Functions
inline -- in header file -- functions are not complex
inline function: change parameters:
E.g.:
inline vec3 operator*(const vec3 &u, const vec3 &v)
inline vec3 operator*(double t, const vec3 &v)
inline vec3 operator*(const vec3 &v, double t)


RTIOW: 3.3 Color Utility Functions
Using vec3 class, create a utility function to write a single pixel's color out to the standard output stream.
Then update main file by using vec3.h and color.h


RTIOW: 4. Rays, a Simple Camera, and Background
RTIOW: 4.1 The ray Class
All tray tracers: have a ray class and compute what color is seen along a ray.
A -- the ray origin, b is the ray direction, P is a 3D position along a line in 3D
=> P(t) = A + tb.


RTIOW: 4.2 Sending Rays Into the Scene
Steps: the ray tracer sends rays through pixels and computes the color seen in the direction of those rays
1) Calculate the ray from the eye to the pixel
2) Determine which objects the ray intersects
3) Compute a color for the intersection point
We can do a simple camera for getting the code up and running. 
Setting up the pixel dimensions for the rendered image: Use 16:9 aspect ratio, not square
Setting up a virtual viewport (to pass our scene rays): pick a viewport two units in height.
focal length: the distance between the project plane and the projection point to be one unit.
Note: focal length not focus distance.
Put the eye at (0,0,0), y-axis go up, x-axis to right. Do not make the ray direction a unit length vector.
auto + initialization expression;
ray_color(ray) -- depending on the height of the y coordinatie after scaling the ray direction to unit length (so -1.0 < y < 1.0) => a horizontal gradient to the color + the vertical gradient.



