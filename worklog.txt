I am starting to work through Ray Tracing in One Weekend.

RITOW: 1. Overview
Ray tracing: a path tracer.
Final Outcome: a ray tracer that produces some great images.
Why C++: fast, portable, and most production movie and video game renderers are written in C++.


RITOW: 2.1 The PPM Image Format
Way to see an image: write it to a file.
For plain text ppm file, some Notes in C++:
First, pixels: write from left to right
Second, rows: write from top to bottom
Third, each of components range: high dynamic


RITOW: 2.2 Creating an Image File
We need to redirect it to an image file. (because the file is written to the program output) -- Use > (which is a redirection operator)
For Mac/Linux: build/inOneWeekend > image.ppm
For Windows: build\Release\inOneWeekend.exe > image.ppm
On Mac, using ToyViewer to open the output file (or Google "ppm viewer")


RITOW: 2.3 Adding a Progress Indicator
Advantages: track the progress of a long render; identify a run that's stalled out due to an infinite loop or other problem.
image -- std::cout
error -- std::cerr


RITOW: 3. The vec3 Class
Almost all graphics programs -- some classes for storing geometric vectors and colors.
Vectors are 4D: 3D+a homogeneous coordinate for geometry & RGB+an alpha transparency channels for colors.
We use the same class vec3 for colors, locations, directions, offsets, etc.
Two aliases for vec3: point2 and color.


RITOW: 3.1 Variables and Methods
vec3 class: public
default conductor, conductor, assignment operators
We use double (but some ray tracers use float, both ok)
//Type aliases for vec3
using point3 = vec3; // 3D point
using color = vec3; // RGB color


RITOW: 3.2 vec3 Utility Functions
inline -- in header file -- functions are not complex
inline function: change parameters:
E.g.:
inline vec3 operator*(const vec3 &u, const vec3 &v)
inline vec3 operator*(double t, const vec3 &v)
inline vec3 operator*(const vec3 &v, double t)


RITOW: 3.3 Color Utility Functions
Using vec3 class, create a utility function to write a single pixel's color out to the standard output stream.
Then update main file by using vec3.h and color.h


RITOW: 4. Rays, a Simple Camera, and Background
RITOW: 4.1 The ray Class
All tray tracers: have a ray class and compute what color is seen along a ray.
A -- the ray origin, b is the ray direction, P is a 3D position along a line in 3D
=> P(t) = A + tb.


RITOW: 4.2 Sending Rays Into the Scene
Steps: the ray tracer sends rays through pixels and computes the color seen in the direction of those rays
1) Calculate the ray from the eye to the pixel
2) Determine which objects the ray intersects
3) Compute a color for the intersection point
We can do a simple camera for getting the code up and running. 
Setting up the pixel dimensions for the rendered image: Use 16:9 aspect ratio, not square
Setting up a virtual viewport (to pass our scene rays): pick a viewport two units in height.
focal length: the distance between the project plane and the projection point to be one unit.
Note: focal length not focus distance.
Put the eye at (0,0,0), y-axis go up, x-axis to right. Do not make the ray direction a unit length vector.
auto + initialization expression;
ray_color(ray) -- depending on the height of the y coordinatie after scaling the ray direction to unit length (so -1.0 < y < 1.0) => a horizontal gradient to the color + the vertical gradient.


RITOW: 5. Adding a Sphere
RITOW: 5.1 Ray-Sphere Intersection
The equation for a sphere: x^2 + y^2 + z^2 = R^2 => (x-Cx)^2 + (y-Cy)^2 + (z-Cz)^2 = r^2
& our ray: P(t) = A + t(b)
=> (P - C)(P - C) = r^2 => t^2*b*b + 2t*b*(A-C) + (A-C)*(A-C) - r^2 = 0
Solve the above equation for t.


RITOW: 5.2 Creating Our First Raytraced Image
Take the math and hard-code
But lack something: shading and reflection rays and >1 objects.
And we need to fix the issue: when z=+1, we will get the same picture.


RITOW: 6. Surface Normals and Multiple Objects
RITOW: 6.1 Shading with Surface Normals
get a surface normal => shade => a vector that is perpendicular to the surface at the point of intersection
t > 0 => in front of the camera


RITOW: 6.2 Simplifying the Ray-Sphere Intersection Code
Simplify: when b = 2h, => solution = (-h-sqrt(h^2-ac))/a
replace a vector dotted with itself = the squared length of that vector replaced by b = 2h


RITOW: 6.3 An Abstraction for Hittable Objects
Have an array of spheres => solution: make an abstract class for anything a ray might hit.
Therefore, use "hittable": emphasized the member function that unites them.
hit(): takes in a ray => add a valid interval for hits min_t to max_t.


RITOW: 6.4 Front Faces Versus Back Faces
This design decision for normals is whether they should always point out.
We want to determine which side of the surface that the ray is coming from:
So the ray is outside the sphere => the normal point outward;
              inside             =>                  inward;
Another: If the ray and the normal face in the same direction => taking the dot product of the two vectors => if positive => the ray is inside the object.
Add front_face tracking to hit_record struct.
Add surface side determination to the class.


RITOW: 6.5 A List of Hittable Objects
A hittable: a generic object, and the ray can intersect with.
So we add a clase that stores a list of hittables.


RITOW: 6.6 Some New C++ Features
shared_ptr<type>: a pointer to some allocated type, with reference-counting semantics.
                  every time you assign its value to another shared pointer, the reference count++.
                  As the shared pointers go out of scope (at the end of a block or function), reference count--.
                  #include <memory>
make_shared<thing>(...): allocates a new instance of type thing, using the constructor parameters, return a shared_ptr<thing>. => we can using auto type specifier.


RITOW: 6.7 Common Constants and Utility Functions
define pi as our own constant.
And define infinity by std::numeric_limits<double>::infinity();
rtweekend.h: common useful constants and future utility functions


RITOW: 7. Antialiasing
RITOW: 7.1 Some Random Number Utilities
a random number generator that returns real random numbers.
rand(): #include <cstdlib>
        0 ~ RAND_MAX
Another: Use uniform distribution in #include <random>


RITOW: 7.2 Generating Pixels with Multiple Samples
several samples within pixel -> each sends a ray => the color of each ray should be averaged
=> Create a camera class and update write_color() function.


RITOW: 8. Diffuse Materials
RITOW: 8.1 A Simple Diffuse Material
Diffuse objects(don't emit light) take on the color of their surroundings, but they modulate that with their own intrinsic color.
The darker the surface, the more likely absorption is.
One way: ideal diffuse surface.
Pick a random point in a unit radius sphere. And then use a rejection method.
ve3.h:
random utility function
random_in_unit_sphere() function
update ray_color() using a random ray directino in main.cpp


RITOW: 8.2 Limiting the Number of Child Rays
ray_color function is recursive: stop time => gails to hit anything. However, it's a long time.
Therefore we need to limit the maximum recursion depth.


RITOW: 8.3 Using Gamma Correction for Accurate Color Intensity
"Gamma corrected": when we cannot see the shadow, we can use "gamma 2" to get a lighter color.
Raising the color to the power 1/gamma, or use square-root.


RITOW: 8.4 Fixing Shadow Acne
Exception: t is near to 0, but not exactly equal to 0, e.g., t = 0.000000001
Therefore, we need to ignore hits very near zero. => git rid of the shadow acne problem.


